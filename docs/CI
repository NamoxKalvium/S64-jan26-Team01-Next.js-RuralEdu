This task implements a Continuous Integration (CI) Pipeline for a Next.js project using GitHub Actions.
The goal is to ensure that every push or pull request automatically verifies the codebase by running:

âœ… Linting (ESLint)
âœ… Unit Tests (Jest with coverage)
âœ… Build Verification (Next.js build)
âœ… Optional Deployment (only on main branch)

This ensures code quality, prevents broken builds, and improves team collaboration.

ğŸ¯ Objectives
By completing this task, I achieved:

Automated CI checks on every push and pull request.

Prevented bad code from being merged into main.

Improved reliability through lint + test + build checks.

Added caching and concurrency for faster pipelines.

Enabled secure deployment support using GitHub Secrets.

ğŸ—ï¸ Workflow File Setup
ğŸ“‚ Directory Structure
The workflow is created inside:

.github/
 â””â”€â”€ workflows/
      â””â”€â”€ ci.yml
âš™ï¸ GitHub Actions Workflow File (ci.yml)
ğŸ“Œ File: .github/workflows/ci.yml

name: CI Pipeline

on:
  push:
    branches: [main, develop]

  pull_request:
    branches: [main, develop]

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: "npm"

      - name: Install Dependencies
        run: npm ci

      - name: Run Linter
        run: npm run lint

      - name: Run Unit Tests
        run: npm test -- --coverage

      - name: Build Application
        run: npm run build

      - name: Deploy Application
        if: github.ref == 'refs/heads/main'
        run: echo "Deploying application..."
ğŸ§© Workflow Explanation (Step-by-Step)
âœ… Step 1: Workflow Trigger
The workflow triggers automatically when:

Code is pushed to main or develop

A pull request is created targeting main or develop

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
This ensures that both development and production branches are protected.

âœ… Step 2: Concurrency Optimization
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true
This ensures:

Only one workflow runs per branch at a time.

If another commit is pushed, the old pipeline cancels automatically.

ğŸ“Œ Benefit: Saves CI minutes and avoids duplicate builds.

âœ… Step 3: Checkout Code
- name: Checkout Repository
  uses: actions/checkout@v3
This downloads the latest repository code into the GitHub runner.

âœ… Step 4: Node.js Setup + Caching
- name: Set up Node.js
  uses: actions/setup-node@v3
  with:
    node-version: 18
    cache: "npm"
This ensures:

Node.js version is consistent (Node 18)

Dependencies are cached â†’ faster builds

âœ… Step 5: Install Dependencies
- name: Install Dependencies
  run: npm ci
We use npm ci instead of npm install because:

Faster

Uses exact versions from package-lock.json

More reliable for CI environments

âœ… Step 6: Run ESLint
- name: Run Linter
  run: npm run lint
This checks for:

Syntax issues

Unused imports

Bad formatting

Code style problems

âœ… Step 7: Run Unit Tests with Coverage
- name: Run Unit Tests
  run: npm test -- --coverage
This ensures:

Unit tests pass

Coverage report is generated

Code changes donâ€™t break features

âœ… Step 8: Build Next.js Project
- name: Build Application
  run: npm run build
This verifies the app can successfully compile.

ğŸ“Œ This prevents merging code that breaks production builds.

âœ… Step 9: Deployment Step (Optional)
- name: Deploy Application
  if: github.ref == 'refs/heads/main'
  run: echo "Deploying application..."
This deployment runs only when code is pushed to main.

In real-world deployment, this can be replaced with:

AWS ECS Deploy

Vercel Deployment

Azure Web App Deployment

Netlify Deployment

ğŸ“¦ Required Scripts in package.json
To ensure CI works properly, these scripts were added/verified:

ğŸ“Œ File: package.json

"scripts": {
  "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
  "test": "jest",
  "build": "next build"
}
ğŸ” GitHub Secrets Setup (Secure Deployments)
To prevent exposing credentials publicly, deployment secrets are stored in GitHub Actions Secrets.

Steps to Add Secrets
Go to GitHub Repository

Click Settings

Click Secrets and Variables

Click Actions

Click New Repository Secret

Add keys like:

AWS_ACCESS_KEY_ID

AWS_SECRET_ACCESS_KEY

AZURE_WEBAPP_PUBLISH_PROFILE

Example Usage in Workflow
env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
ğŸ“Œ Benefit: Secrets remain private and never appear in the repo.

ğŸ“¸ Workflow Verification
To validate CI pipeline:

Steps Followed
Created .github/workflows/ci.yml

Pushed code to GitHub

Opened the Actions tab

Verified all steps executed in order:

âœ… Install Dependencies
âœ… Lint
âœ… Tests
âœ… Build
âœ… Deploy (only on main)

ğŸ§ª Evidence / Screenshots Required
The following screenshots should be included in submission:

Workflow YAML file in GitHub

GitHub Actions successful run summary

Logs showing lint/test/build output

Test coverage logs

ğŸ“Œ Location: GitHub â†’ Actions tab â†’ Click the workflow run

ğŸ“Š CI Pipeline Flow Diagram
Push / Pull Request
        |
        v
Checkout Repository
        |
        v
Setup Node.js + Cache Dependencies
        |
        v
Install Dependencies (npm ci)
        |
        v
Run ESLint (npm run lint)
        |
        v
Run Tests + Coverage (npm test -- --coverage)
        |
        v
Build Next.js App (npm run build)
        |
        v
Deploy (only if branch = main)
ğŸ’¡ Reflection
âœ… Why CI is Important
CI improves software quality by ensuring:

Every commit is tested before merging.

Broken code is detected early.

Teams collaborate without fear of breaking production.

Deployment becomes safe and repeatable.

âš¡ How Caching Improved Performance
Using:

cache: "npm"
reduced pipeline runtime significantly because dependencies are not downloaded repeatedly.

This is especially useful when projects grow larger.

ğŸ” How Concurrency Helps
Concurrency prevents wasted builds:

If multiple commits are pushed quickly,

Only the latest commit runs fully,

Previous builds are canceled.

This reduces unnecessary workload and saves time.

ğŸ” Why Secrets are Critical
Hardcoding credentials in YAML is dangerous because:

Anyone can view the repository workflow

Secrets can be stolen

Cloud services may get compromised

Using GitHub Secrets ensures credentials remain protected.

ğŸ“Œ Conclusion
This CI pipeline ensures the Next.js application is always tested, linted, and build-ready before merging.
It improves productivity, reliability, and makes the project ready for production deployment.



