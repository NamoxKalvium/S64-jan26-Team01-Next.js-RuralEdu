This task focuses on making the backend APIs and overall system structure easy to understand, maintain, and extend.

By completing this task, we achieved:

âœ… Complete API Documentation (Swagger UI / Postman Collection)
âœ… Centralized versioning + metadata for documentation
âœ… System Architecture Documentation (ARCHITECTURE.md)
âœ… Clear explanation of data flow, deployment, and folder structure
âœ… Documentation links added to the main README
âœ… Reflection on documentation maintenance & onboarding

ğŸ§° Tech Stack Used
Layer	Technology
Frontend	Next.js (App Router)
Backend	Next.js API Routes (/app/api)
Database	PostgreSQL
ORM	Prisma
Authentication	JWT
Documentation	Postman Collection (or Swagger)
Deployment	AWS / Azure
CI/CD	GitHub Actions
ğŸ“‘ 1. API Documentation
For documenting our API endpoints, we used:

âœ… Option B: Postman Collection (Recommended for Next.js API routes)
Postman was selected because it is easy to maintain, supports authentication testing, and allows exporting/importing documentation.

ğŸ“‚ API Documentation Location
ğŸ“Œ Stored inside the repository at:

docs/postman_collection.json
ğŸ“Œ API Metadata
Field	Value
API Version	v1.0.0
Base URL	http://localhost:3000
Production URL	https://your-domain.com
Authentication	Bearer Token (JWT)
Last Updated	2026-02-11
ğŸ” Authentication Method
Our APIs use JWT Authentication.

Authorization Header Format
Authorization: Bearer <JWT_TOKEN>
ğŸ§ª API Endpoints Included
Below is the list of endpoints documented inside Postman.

ğŸŸ¢ Auth APIs
âœ… Signup User
POST /api/auth/signup

Request Body
{
  "name": "Alice",
  "email": "alice@example.com",
  "password": "mypassword"
}
Success Response (201)
{
  "success": true,
  "message": "Signup successful",
  "data": {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com"
  }
}
Failure Response (400)
{
  "success": false,
  "message": "User already exists"
}
âœ… Login User
POST /api/auth/login

Request Body
{
  "email": "alice@example.com",
  "password": "mypassword"
}
Success Response (200)
{
  "success": true,
  "message": "Login successful",
  "token": "<JWT_TOKEN>"
}
Failure Response (401)
{
  "success": false,
  "message": "Invalid credentials"
}
ğŸ”µ Protected APIs
âœ… Get Current User Info
GET /api/users

Headers
Authorization: Bearer <JWT_TOKEN>
Success Response (200)
{
  "success": true,
  "message": "Protected data",
  "user": {
    "id": 1,
    "email": "alice@example.com"
  }
}
Failure Response (403)
{
  "success": false,
  "message": "Invalid or expired token"
}
ğŸ“¦ How to Use Postman Collection
Step 1: Import Collection
Open Postman

Click Import

Select:

docs/postman_collection.json
Step 2: Setup Environment
Create an environment in Postman with:

Variable	Value
base_url	
token	<paste JWT after login>
ğŸ“Œ Postman Documentation Proof
ğŸ“¸ Screenshots to include in submission

Collection overview

Signup API tested successfully

Login API tested successfully

Protected route with token success

Protected route without token failure

Example folder for screenshots:

docs/screenshots/
ğŸ—ï¸ 2. Architecture Documentation (ARCHITECTURE.md)
We created a dedicated architecture file:

ğŸ“Œ File Location:

ARCHITECTURE.md
This file contains:

âœ… High-level overview
âœ… Folder structure explanation
âœ… API request flow diagram
âœ… Database + Prisma schema explanation
âœ… Deployment design (AWS/Azure)
âœ… CI/CD workflow overview
âœ… Secrets and environment strategy
âœ… Onboarding steps for contributors

ğŸ§¾ Architecture Overview
High Level System Components
Our application follows a standard modern full-stack architecture:

Components
Client (Browser) â†’ Next.js frontend UI pages

Backend (API Routes) â†’ Next.js server-side routes under /app/api

Database â†’ PostgreSQL via Prisma ORM

Authentication â†’ JWT tokens

Cloud Storage (Optional) â†’ AWS S3 / Azure Blob

Monitoring â†’ CloudWatch / Azure Monitor

CI/CD â†’ GitHub Actions

ğŸ” System Data Flow
Request Flow Example (Protected Route)
User Browser
   |
   | 1. Request /api/users
   | 2. Sends Authorization: Bearer token
   v
Next.js Middleware / API Route
   |
   | 3. Verify JWT
   v
Prisma ORM
   |
   | 4. Query PostgreSQL
   v
Database Response
   |
   v
API sends JSON response to client
ğŸ“Œ Mermaid Architecture Diagram (Add in ARCHITECTURE.md)
flowchart TD
    A[Client Browser] -->|Request| B[Next.js API Route]
    B -->|JWT Verify| C[Middleware/Auth Logic]
    C -->|Query| D[Prisma ORM]
    D -->|SQL| E[PostgreSQL DB]
    E --> D
    D --> B
    B --> A
ğŸ“‚ Directory Structure
Current recommended structure:

src/
 â”£ app/
 â”ƒ   â”£ api/
 â”ƒ   â”ƒ   â”£ auth/
 â”ƒ   â”ƒ   â”ƒ   â”£ signup/route.ts
 â”ƒ   â”ƒ   â”ƒ   â”— login/route.ts
 â”ƒ   â”ƒ   â”— users/route.ts
 â”ƒ   â”£ page.tsx
 â”ƒ   â”— layout.tsx
 â”£ lib/
 â”ƒ   â”£ prisma.ts
 â”ƒ   â”£ jwt.ts
 â”ƒ   â”— responseHandler.ts
 â”£ utils/
 â”ƒ   â”— validators.ts
 â”— middleware.ts
ğŸ›¢ï¸ Database Architecture
Database Used
PostgreSQL

ORM Used
Prisma

Example User Model
model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  role      String   @default("user")
  createdAt DateTime @default(now())
}
Key Constraints Implemented
email is unique

id is primary key

password stored in hashed format (bcrypt)

ğŸ” Environment Variables and Secrets
Local Environment Files
We maintain:

.env.local â†’ real secrets (ignored in git)

.env.example â†’ template for contributors

Example .env.example:

DATABASE_URL=postgresql://username:password@localhost:5432/dbname
JWT_SECRET=your-secret-key
NEXT_PUBLIC_BASE_URL=http://localhost:3000
â˜ï¸ Deployment Architecture
Hosting
Depending on deployment choice:

AWS Option
ECS / EC2 / Elastic Beanstalk

CloudWatch Logs

RDS PostgreSQL

S3 for uploads

Azure Option
Azure App Service

Azure Monitor Logs

Azure PostgreSQL

Azure Blob Storage

âš™ï¸ CI/CD Pipeline (GitHub Actions)
CI pipeline runs:

âœ… Install dependencies
âœ… Run lint
âœ… Run tests
âœ… Build Next.js app
âœ… Deploy (optional)

Workflow location:

.github/workflows/ci.yml
ğŸ‘¨â€ğŸ’» Contributor Onboarding
Step 1: Clone Repository
git clone <repo-url>
cd frontend
Step 2: Install Dependencies
npm install
Step 3: Setup Environment Variables
cp .env.example .env.local
Update values inside .env.local.

Step 4: Run Prisma Migration
npx prisma migrate dev --name init
Step 5: Start Server
npm run dev
ğŸ”„ Documentation Update Checklist
Whenever a new API is added:

âœ… Add endpoint to Postman Collection
âœ… Add request/response examples
âœ… Export collection again into docs/postman_collection.json
âœ… Update API version if breaking changes occur
âœ… Update ARCHITECTURE.md if flow changes
âœ… Add screenshot evidence if required

ğŸ”— Linking Docs in README
Main README contains:

ğŸ“Œ Postman Collection path
ğŸ“Œ Architecture file link
ğŸ“Œ Version info
ğŸ“Œ Screenshot evidence section

Example:

## Documentation
- API Docs: `docs/postman_collection.json`
- Architecture Guide: `ARCHITECTURE.md`
ğŸ“¸ Screenshots Required (Submission Proof)
Add screenshots inside:

docs/screenshots/
Screenshots to capture
âœ… Postman collection overview
âœ… Signup request success
âœ… Login request success
âœ… Protected route success with JWT
âœ… Protected route failure without JWT
âœ… Architecture diagram screenshot
âœ… README links proof

ğŸ§  Reflection
Why API Documentation Matters
API documentation helps:

new developers understand endpoints quickly

reduce dependency on team members for API usage

avoid mistakes in request body formatting

standardize authentication and error handling

Without documentation, developers waste time guessing payload formats and response structures.

How Documentation Improves Onboarding
A new contributor can:

clone the repo

import Postman collection

test endpoints immediately

understand folder structure using ARCHITECTURE.md

This makes onboarding faster and reduces confusion.

Version Consistency Strategy
We maintain versioning using:

API Version: v1.0.0

version field in Postman collection metadata

update documentation when endpoints change

For future releases:

patch update â†’ v1.0.1 (minor fixes)

minor update â†’ v1.1.0 (new endpoint)

major update â†’ v2.0.0 (breaking changes)

ğŸ“Œ Final Notes
This documentation ensures the project is production-ready, maintainable, and scalable for future development.